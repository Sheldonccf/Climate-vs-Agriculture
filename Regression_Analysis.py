# -*- coding: utf-8 -*-
"""
Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NZivjAGBPvNSJ_PdbGEQC4i6UKbvg6kh
"""

#!pip install stats-can
#!pip install sklearn
#!pip install numpy
#!pip install matplotlib
#!pip install statsmodels

## Reading the Dataset

#pip3 install stats-can Install the Statitsics Canada API
#conda install -c conda-forge stats_can
import pandas as pd
import numpy as np

from stats_can import StatsCan #Import StatsCan library 
sc = StatsCan()
crop_yield = sc.table_to_df("32-10-0359-01") #Convert crop yield data table into pandas dataframe

crop_yield.columns = [c.replace(' ', '_') for c in crop_yield.columns] #Improve header readability

#Drop unnecessary columns from crop yield table
crop_yield = crop_yield.drop(columns=["DGUID"]) 
crop_yield = crop_yield.drop(crop_yield.loc[:,"UOM_ID":"COORDINATE"].columns, axis = 1)
crop_yield = crop_yield.drop(crop_yield.loc[:,"STATUS":"DECIMALS"].columns, axis = 1)
crop_yield = crop_yield.dropna() #Not sure on this one?

#Reset index based on new number of rows
crop_yield.reset_index(inplace=True)
crop_yield = crop_yield.drop("index", 1)

def redo_columns(df): #Find averages for provinces that have more than one weather station; amalgamate these averages into new columns named for provinces and discard remaining columns
  df['Alberta'] = df[['CALGARY', 'EDMONTON']].mean(axis=1)
  df['Quebec'] = df[['MONTREAL', 'QUEBEC']].mean(axis=1) #Means of multiple weather stations
  df['Ontario'] = df[['OTTAWA', 'TORONTO']].mean(axis=1)
  new_columns = {'MONCTON': 'New Brunswick',
        'SASKATOON': 'Saskatchewan',
        'STJOHNS': 'Newfoundland and Labrador',
        'VANCOUVER': 'British Columbia',
        'WINNIPEG': 'Manitoba',
        'HALIFAX': 'Nova Scotia',
        'CHARLOTTETOWN': 'Prince Edward Island'} #Dict to replace weather station names with provinces

  df.rename(columns=new_columns,
          inplace=True)

  df.drop(['CALGARY','EDMONTON','MONTREAL','OTTAWA','QUEBEC','TORONTO','WHITEHORSE'], axis = 1,inplace=True) #Remove columns that provided means 
  return df


#Provincial precipitation

#Read in broad temperature data (all and PEI)

temp = pd.read_csv('https://raw.githubusercontent.com/BenKelly-Data/Canadian-Agricutural-Yields-vs-Climate/main/temperature_data.csv')
pei_temp_2012 = pd.read_csv('https://raw.githubusercontent.com/BenKelly-Data/Canadian-Agricutural-Yields-vs-Climate/main/en_climate_monthly_PE_8300300_1943-2012_P1M.csv')
pei_Yearly_temp = pei_temp_2012.groupby(["Year"]).mean() #Mean data by year
pei_temp_data_2013 = pd.read_csv('https://raw.githubusercontent.com/BenKelly-Data/Canadian-Agricutural-Yields-vs-Climate/main/pei_2013.csv')
pei_temp_data_2013.set_index('YEAR', inplace = True)

#Select only temp data from PEI daata
pei_temp_data_2013 = pei_temp_data_2013[['Mean Temp (°C)']]
pei_Yearly_temp = pei_Yearly_temp[['Mean Temp (°C)']]
pei_temp = pei_Yearly_temp.append(pei_temp_data_2013) #Append 2013-2019 data to 90's-2012 data
#Match indexes between 
pei_temp['YEAR'] = pei_temp.index
temp.set_index('YEAR')

#Join PEI data to the rest of the provinces
temp = temp.join(pei_temp.set_index('YEAR'),on = 'YEAR',how = 'left')

#Match formating between columns and with precipitation data
temp.rename(columns = {'Mean Temp (°C)':'MEAN_TEMPERATURE_CHARLOTTETOWN'}, inplace = True)
temp.columns = [t.replace('MEAN_TEMPERATURE_', '') for t in temp.columns]

temp = redo_columns(temp)

#GitHub Precip Data
precip = pd.read_csv('https://raw.githubusercontent.com/BenKelly-Data/Canadian-Agricutural-Yields-vs-Climate/main/precipitation_data_updated.csv')
precip.rename(columns = {'Total Precip (mm)':'TOTAL_PRECIPITATION_CHARLOTTETOWN'}, inplace = True)
precip.columns = [p.replace('TOTAL_PRECIPITATION_', '') for p in precip.columns]

precip= redo_columns(precip)
precip['YEAR'] = temp['YEAR'] #Re-add year data

precip.drop(precip.tail(1).index,inplace = True) #Remove extra error row
precip['YEAR'] = precip['YEAR'].astype(int)

"""## Data Cleaning"""

#FOCUSSING ON PROVINCIAL DATA
provs = ['Alberta', 'British Columbia', 'Manitoba', 'New Brunswick', 
         'Newfoundland and Labrador', 'Nova Scotia', 'Ontario', 
         'Quebec', 'Saskatchewan','Prince Edward Island']

prov_ag = crop_yield[crop_yield['GEO'].isin(provs)] #Subset crop data to just provincial data (not national or regional)

prov_ag[["REF_DATE"]] = prov_ag[["REF_DATE"]].astype(str) #Change year to be a string

prov_ag=prov_ag.rename(columns = {'REF_DATE':'YEAR'})

prov_ag = prov_ag.replace({'-01-01': ''}, regex=True)
prov_ag[["YEAR"]] = prov_ag[["YEAR"]].astype(int)
prov_ag = prov_ag[prov_ag.YEAR >= 1940]
prov_ag = prov_ag[prov_ag.YEAR <= 2019]
prov_ag = prov_ag.reset_index()

#Might be able to make one function with temp/precip as an argument, but seems to get complicated within the apply
def inTemp(row):
  t = prov_ag.iloc[[row.name]] #Get row index of current row
  y = t['YEAR'] #Find the year associated with the row
  y = int(y) #Ensure it's an integer

  p = t['GEO'].astype("string").to_string() #Get province as string (redundancy needed)
  head, sep, p = p.partition('  ') #Clean extra space created by making the string
  p = p.lstrip() #Keep removing extra spaces
  test = temp.loc[temp['YEAR'] == y] #Get the temperatures for the given year
  v = test[p] #Select the temp for the given province within selected year
  return float(v) #Return temp

#Similar commenting as above, just adapted to precipitation data
def inPrecip(row):
  t = prov_ag.iloc[[row.name]]
  y = t['YEAR']
  y = int(y)

  p = t['GEO'].astype("string").to_string()
  head, sep, p = p.partition('  ')
  p = p.lstrip()
  test = precip.loc[precip['YEAR'] == y]
  v = test[p]
  return float(v)

print('')
print('Data formatting takes 6-10 minutes, thanks for waiting!')
print('')

#TAKES 3 MIN
#Add temperature column to crop yield data
prov_ag["TEMP"] = ''
prov_ag["TEMP"] = prov_ag.apply(inTemp, axis=1)

print('Temperature data is in, now for precipitation!')
print('')

#Add precipitation column to crop yield data
prov_ag["PRECIP"] = ''
prov_ag["PRECIP"] = prov_ag.apply(inPrecip, axis=1)

print('Data ready! Look for a GUI!')
print('')
"""

```
# This is formatted as code
```

## GUI Creation & MatPlotLib Integration"""

from tkinter import *
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import tkinter.messagebox

#crop_yield = pd.read_csv("dat.csv") # theoretically won't need this part once StatsCan gets back up and running
crop_yield = prov_ag

# Generates the values for the drop down menus and sorts the lists for easier readability
province_list = sorted(crop_yield["GEO"].unique())
crop_list = sorted(crop_yield["Type_of_crop"].unique())
prov_ag = crop_yield


"""## Linear Regression Analysis"""

import statsmodels.api as sm
import statsmodels.formula.api as smf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#Step 1: Testing the existence of a linear relationship between climate change
#and agricultural crop yield in Canada

#Declare Global Constants to be used as queries
DEFAULT_YEAR = 2018
DEFAULT_CROP = 'Barley'
SIGNIFICANCE_LEVEL = 0.05

#class to summarize if there is a linear correlation 
#between each pair of (temp, precip) (yield) variables

class LinearValidate:
  '''
  Return a dataframe summarizing the existence of a linear correlation 
  between each pair of (temp, precip) (crop_type) variables in each province.
  Each row of this returned data frame has three columns 'Province_name', 
  'Crop_name', 'Existence_of_linear_relation' 

  Example output:
  Province_name   Crop_name   Existence_of_linear_relation
  Alberta         Barley      No
  Alberta         ...         ...
  ...             ...         ...
  ...             ...         ...
  Saskachewan     Wheat       No
  '''

  def __init__(self):
    self.Harvest_disposition = 'Average yield (kilograms per hectare)'
    self.ProvLst = prov_ag[(prov_ag.YEAR	== 2018) & 
                           (prov_ag.Type_of_crop.str.contains(DEFAULT_CROP)) &
               (prov_ag.Harvest_disposition == self.Harvest_disposition)].GEO.values    
    self.ProvRecord = []
    self.CropRecord = []
    self.FTestRecord = []
    self.validate(prov_ag)
  
  def ProvCropType(self, Df_ag, Prov):
    return prov_ag[(prov_ag.GEO == Prov) & (prov_ag.YEAR	== DEFAULT_YEAR) & 
                   (prov_ag.Harvest_disposition == self.Harvest_disposition)].Type_of_crop.values

  def validate(self, Df_ag):
    for ProvName in self.ProvLst:
      ThisProvCrop = self.ProvCropType(Df_ag, ProvName)
      for CropName in ThisProvCrop:
        #do a f test to validate  a linear model's fit
        # for this crop's data in 80 years

        #extract the 80-year historical data for ThisProvCrop 
        ThisCropDf = prov_ag[(prov_ag.GEO == ProvName) & 
                   (prov_ag.Type_of_crop == CropName)
                 & (prov_ag.Harvest_disposition == self.Harvest_disposition)
                ].dropna()
               
        # Extract dependent variables y and the independent variables X
        X = ThisCropDf.loc[:, ['TEMP', 'PRECIP']].values
        y = ThisCropDf.loc[:, ['VALUE']].values
        
        if (len(X) == len(y)) and (len(X) != 0):
        #fit a linear model with (X, y)
          X = sm.add_constant(X)
          model = sm.OLS(y, X).fit()
          
          #print(model.pvalues)
        
        #running a f-test for the validity of this model
          if (model.pvalues[0] < SIGNIFICANCE_LEVEL) and \
          (model.pvalues[1] < SIGNIFICANCE_LEVEL) and \
          (model.pvalues[2] < SIGNIFICANCE_LEVEL):
            f_test = 'Yes'
          else:
            f_test = 'No'

        #push the result of the f test onto self.record
        self.ProvRecord.append(ProvName)
        self.CropRecord.append(CropName)
        self.FTestRecord.append(f_test)

    #after the iteration, create the new dataframe
    LinearRegressionTest = {'Province_name': self.ProvRecord,
                'Crop_name': self.CropRecord,
                'Existence_of_linear_relation': 
                self.FTestRecord}

    self.result =  pd.DataFrame(LinearRegressionTest, columns = ['Province_name'
    , 'Crop_name', 'Existence_of_linear_relation'])

  def __print__(self):
    #display all the crops grown in each province and if
    #there is a linear relation between climate change and crop yield
    display(self.result)

  def __filter__(self):
    #display only the ones where a linear model applies
    self.filtered = self.result[self.result.Existence_of_linear_relation == 'Yes']
    display(self.filtered)

#calling the class 
SummaryDf = LinearValidate()

#extract the pairs where a linear model can apply
# both temp and precip have .....
SummaryDf.__filter__()
